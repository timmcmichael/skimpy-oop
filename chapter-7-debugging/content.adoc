:imagesdir: images
:sourcedir: source
// The following corrects the directories if this is included in the index file.
ifeval::["{docname}" == "index"]
:imagesdir: chapter-7-debugging/images
:sourcedir: chapter-7-debugging/source
endif::[]

== 0111 - Debugging and Generative AI
// TODO: Upload source files to GitHub archive

// === #Content for this module is under construction.#

.Help Make These Materials Better!
****
I am actively working to complete and revise this eBook and the accompanying videos. Please consider using the following link to provide feedback and notify me of typos, mistakes, and suggestions for either the eBook or videos:

https://forms.gle/4173pZ1yPuNX7pku6[CIS150AB Course Materials Feedback (Google Form)^]
****

:sectnums!:
=== What's the Point?
// * Distinguish between compile-time and runtime errors
// * Learn some strategies for debugging your code
// * Use the debugging tools available in your IDE

:sectnums:
'''


_Source code examples from this chapter and associated videos are available on https://github.com/timmcmichael/EMCCTimFiles/tree/4bf0da6df6f4fe3e3a0ccd477b4455df400cffb6/OOP%20with%20Java%20(CIS150AB)/07%20Debugging[GitHub^]._

'''

=== Debugging

A _bug_ is an error in your code that causes it to behave in an unexpected way.
This is different from a syntax error, like forgetting a semicolon or misspelling a keyword--those kinds of mistakes will prevent your code from compiling, so you can't even run it.
A bug is when your code runs, but it doesn't do what you want it to do.

Bugs are frustrating, but they are a part of programming.
Like Thanos, they are inevitable.
And like Thanos, you can use ludicrous time traveling to fix (decapitate?) your bugs.
Well, you can't do that last part, but you can fix them in the present; and hopefully, you can do it without too much frustration.

Finding and fixing bugs is called _debugging_, and without realing it, you've been developing your own strategies for debugging since you started writing code.
But as your code becomes more complex, you'll benefit from a more systematic approach to debugging--and you'll want to take advantage of the tools available in your IDE to help you.

=== Types of Errors

We categorize bugs into two general types:

Compile-time errors:: Errors that prevent the compiler from fully processing your source code. These are generally the result of incorrect syntax--in other words, breaking the rules of the language.
Runtime errors:: Errors in which your code compiles, but it does not execute as intended. Crashes are obvious runtime errors, but making an incorrect calculation is also an example of a runtime error.

Fixing compile-time errors is just a matter of looking over your code and correcting the mistake.
That's not always as easy as it sounds--especially for beginners--but at least the compiler and/or your IDE can give you feedback about what and where the mistake is.

Runtime errors can be especially frustrating, especially since we can't always tell at what point the actual error is occurring.
Did I make the mistake at the start of the program when I calculated the answer, is the mistake at the very end where I output it? 
Or did I do something in the middle that accidentally changed the result?
Who knows! And if you're like me, you might have done all three...

.Time To Watch!
****
Intro to Debugging [COMING SOON!]


// video::PR6u4KvAkas[youtube, list=PL_Lc2HVYD16Y-vLXkIgggjYrSdF5DEFnU]
// Files from video:

// * Starter code: https://raw.githubusercontent.com/timmcmichael/EMCCTimFiles/refs/heads/main/OOP%20with%20Java%20(CIS150AB)/HelloWorld.java[`HelloWorld.java`^]
// * Completed code: https://raw.githubusercontent.com/timmcmichael/EMCCTimFiles/refs/heads/main/OOP%20with%20Java%20(CIS150AB)/HelloWorld.java[`HelloWorld.java`^]
****

=== Debugging Tools in Your IDE

Most modern IDEs have built-in tools to help you debug your code.
These tools allow you monitor the variables in your program, step through your code line-by-line, and set breakpoints to pause your program at a specific point.
The more you know about programming, the more useful these tools become.
But even as beginners, these tools can be helpful in finding and fixing bugs in your code.

The most common debugging tools you'll use are:
Watch window:: A window that displays the values of variables in your program.
Breakpoints:: A marker that tells your program to pause at a specific point in your code.
Step Into:: A command that tells your program to execute the next line of code.
Step Over:: A command that tells your program to execute the next line of code, but not to step into any methods that are called.
Step Out:: A command that tells your program to execute the rest of the current method and then pause.
Resume:: A command that tells your program to continue running until it hits the next breakpoint.

These functions are available in most IDEs, but the specifics of how they work can vary.
Even if you're not using Visual Studio Code, the concepts are the same, so you should be able to apply what you learn here to your IDE of choice.

.Time To Watch!
****
Debugging in Java with VS Code [COMING SOON!]

// video::PR6u4KvAkas[youtube, list=PL_Lc2HVYD16Y-vLXkIgggjYrSdF5DEFnU]
// Files from video:

// * Starter code: https://raw.githubusercontent.com/timmcmichael/EMCCTimFiles/refs/heads/main/OOP%20with%20Java%20(CIS150AB)/HelloWorld.java[`HelloWorld.java`^]
// * Completed code: https://raw.githubusercontent.com/timmcmichael/EMCCTimFiles/refs/heads/main/OOP%20with%20Java%20(CIS150AB)/HelloWorld.java[`HelloWorld.java`^]
****

=== Generative AI in Coding

:!sectnums:
==== #The AI content is under construction. Check back soon for updates!#
:sectnums:

Generative Artificial Intelligence is a type of AI that can generate new content based on existing data.
Tools like ChatGPT and Copilot are well-known examples of generative AI.
You can ask a generative AI tool to write song lyrics about about Java programming, for example, and it will producte a https://timmcmichael.github.io/skimpy-oop/chapter-7-debugging/ai_song.html[new song for you^].

Artificial Intelligence is a broad field, and the topic is well beyond the scope of this course.
But generative AI has important implications for the field of software development, so we'll focus on just that aspect of the technology.

==== The Role of Generative AI in Education

Like many teachers, I'm actively wrestling with the role of generative AI in a coding course.
I have many ethical concerns about AI in general, and about generative AI to create code in particular. 
Simply put, these tools can be used in ways that are indisputably unethical. 
Most obviously, students can easily use these tools generate code that is then submitted as the student's own work.

I would like to think it goes without saying, but based on the number of students who deny this, I guess I need to say it: using AI to generate code that you submit as your own is cheating.
It is no different than copying someone else's code and submitting it as your own.

It presents a real challenge for teachers trying to assess student learning, and a real temptation for students struggling to learn--and able to simply let AI do the work for them.

But the impact this technology has had--and will continue to have--on the field of software development is undeniable, and I would be doing you a disservice if we didn't learn a little about it.

==== The Promise of Generative AI in Coding

What does this AI revolution look like for coders?
What does it mean to someone learning to code?
How does it change the job outlook for someone considering a career in software development?

The short answer is: I don't know.
The longer answer is: I don't know, but I'm excited to find out.

For now, we can look at what generative AI can do for us today.
Here are a few of the current and near-future applications of generative AI in coding:

* *Code completion:* Many IDEs already have code completion features that suggest code as you type.
Generative AI can take this a step further by suggesting entire lines of code, or even entire methods.
* *Code generation:* Generative AI can generate code based on a description of what you want the code to do.
* *Code refactoring:* _Refactoring_ is the process of rewriting code without changing the task the code performs. Once we get code working, we can refactor it to make it more efficient, more secure, or more maintainable. In other words, we can make it better. AI can look at our existing code and recommend changes that make it better.
* *Debugging:* Generative AI can help us find and fix bugs in our code--often, before we even run it.
* *Documentation:* Writing good documentation is an important part of software development, but many programmers hate doing it. Generative AI can help us write documentation that is clear, concise, and accurate.

And that's just a few of the obvious applications of generative AI in coding.

What does that mean for the coding profession?
All I can do is guess, but here are some things I *hope* AI does for us:

* *Better software:* If AI can help us write better code, that should lead to better software.
* *Faster development and update cycles:* Again, if AI makes us more efficient, we should be able to develop and update software faster.
* *Improved security:* Hopefully, AI will help us indentify and address security vulnerabilities in our code.
* *More time for high-level effort:* If AI can take on some of the more tedious and boring coding tasks, that should free up mental bandwidth to focus on the more interesting and creative.

My most optimistic hope is that AI will free up programmers to focus on creative applications and problem-solving--and ultimately allow us to create software that improves the world around us.

==== Potential Negative Impacts of AI on Coding

However, I worry that AI will lead to some negative impacts on the programming profession, as well.
Again, I can only guess, but here are some things I *fear* AI will do to us:

* *Decreased job opportunities:* If AI can write code faster and more accurately than humans, that could lead to fewer job opportunities for human programmers. I think this will be especially true for junior programmers, whose workload will be most easily automated.
* *Loss of institutional knowledge:* Every programming team relies on veteran coders who have been around and have a deep understanding of the codebase. When there's a question about what a module does, or why an algorithm was implemented a certain way, those veterans are the ones who have the answers. If AI is generating code, we may lose that institutional knowledge.
* *Decreased quality of entry-level programmers:* If AI can generate code for us, it's possible that we'll see a decrease in the quality of entry-level programmers. People who rely heavily on AI while learning to code may not develop the same problem-solving skills as those who learn to code without AI. 

==== What Does That All Mean for You?

I don't know. 
As excited as I am to see AI reach this tipping point in software development, it's kind of a scary time to be a programming teacher.
Until recently, I've always

Coders who rely heavily on artificial intelligence tools to solve problems may be able to pass themselves off as more skilled than they actually are--indeed, they might even believe themselves to be more skilled than they actually are.
But such coders will be less skilled at testing, debugging and maintaining code, and that could lead to a decrease in the quality of software.
Putting code into production (releasing it in software that people actually use) without understanding it well enough to regiorously test it is a recipe for disaster.







// .Time To Watch!
// ****
// Intro to Generative AI for Coders [COMING SOON!]

// // video::PR6u4KvAkas[youtube, list=PL_Lc2HVYD16Y-vLXkIgggjYrSdF5DEFnU]
// // Files from video:

// // * Starter code: https://raw.githubusercontent.com/timmcmichael/EMCCTimFiles/refs/heads/main/OOP%20with%20Java%20(CIS150AB)/HelloWorld.java[`HelloWorld.java`^]
// // * Completed code: https://raw.githubusercontent.com/timmcmichael/EMCCTimFiles/refs/heads/main/OOP%20with%20Java%20(CIS150AB)/HelloWorld.java[`HelloWorld.java`^]
// ****



'''
:sectnums!:
// === Check Yourself Before You Wreck Yourself (on the assignments)
//
// ==== Can you answer these questions?

// ****
// 
// 1. 
//
// 2. 
//
// ****
:sectnums:
