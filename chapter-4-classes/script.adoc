Once we can work with variables and create methods, we're ready to start learning about object-oriented programming, or OOP--beginning with a general look at what OOP is, and how our programs can be organized into classes and objects.

So, what is Object-Oriented Programming? A very technical way to define it is to say that in OOP, we're taking data and the code to manipulate that data, and bundling them together into objects, instead of keeping data separate and passing it into the methods that need it. That's an accurate description, but I'm going to encourage a more tangible way of thinking about it.

What I like to say is that OOP lets us think about programs the way we think about the world around us. I'm sure there are exception, but I think most of us tending to see the world as a bunch of objects interacting with one another. When we walk into a classroom, we see a teacher and some students, and they're talking to each other. We see the teacher writing on a whiteboard and we see students typing on laptops. All of those objects have information that's associated with them. The teacher has a name and a subject they teach; each student has a name and a student ID. The objects also have things they can do, or things other objects can do with them. The teacher can ask the students a question, and a student can answer. The teacher can write on the board, and students can take notes in their laptops.

OOP gives us the ability to see our programs in the same way--a bunch of objects that have information and behaviors, and those objects interact with each other. Game development makes for really intuitive examples of this. In a game like fortnite, you have a player object, and that player object has a position, a health level, and a score. The player object can move, jump, and shoot. The player object interacts with other objects in the game, like the environment and other players. The player object can collide with the environment, shoot at other players, dance when they win, and so on. 

But as we'll see, OOP isn't just for game development. OOP is popular enough that if you go into software development, you're going to work with it. You might not be 100% of the time, and it might not be the only thing you do, but it's just too pervasive to avoid.

In OOP, everything begins with classes. Until now, our class has been the entire program, starting with a main() method and containing other methods to help us stay organized. But for us, the main purpose of a class is to be a blueprint for creating objects. If you picture an old-school set of blueprints, that really has all the information you need to build a house. The blueprint tells you how big the house is, how many rooms it has, where the windows are, and so on. 

Another popular analogy for a class that might work better for you is a recipe. And again we'll go old school and think about a recipe written on an index card, maybe like your grandma has. The recipe tells you what ingredients you need, how much of each ingredient, and what steps you need to take to make a cake.

A blueprint by itself isn't very useful. It doesn't actually provide any shelter other than maybe holding it up over my head if it starts to rain. And I can't eat a recipe. But I can take that blueprint and make a bunch of houses from it, and I can make a bunch of cakes from that recipe. 

Let's go back to that idea of a classroom and look at it as an OOP example. To help us visualize these classes and objects, we're going to use some simple diagrams. If you're curious, this is called UML--though I'm simplifying it a lot since we're beginners. But it's the standard format every programmer uses to draw class diagrams.

The top of a class diagram has the class name, and we'll start with the Teacher class. You know I'm uptight about identifiers, so I'll point out the capital T at the begining and the lack of an S at the end. Even though I can have a bunch of teachers, the class is singular. Remember, one recipe, a bunch of cakes. If a class name has multiple words, we capitalize the first letter of each word--so it's the same as our variables and methods, but we're starting with a capital, which shows that it's a class. If you're nerdy like me, you're dying to know that this is called PascalCase, because it is used in an old programming language called Pascal. [named after Blaise Pascal, show a picture]

Below the class name, I'm going to list the things we need to keep track of related to a teacher. A teacher has a name, a subject, an office number, and you can imagine a bunch of other things. These are the things that make an individual teacher unique, and we call them attributes. Below the attributes will be all of the things a teacher can do, or that we can do with a teacher. Lecture, call on a student, write on the board and so on. We call these behaviors.

If we look around the classroom and see what other objects are there, we'll see students. So we'll have a Student class. The Student class will have attributes like a name, a student ID, and a grade. And behaviors like raise a hand, fall asleep, and ask a question.

Again, these classes are blueprints, so they define what a teacher is and what a student is. In order to use them in a program, we'll need to create objects from them. I'll need to have one object from the Teacher class, and I'll need to make a bunch of objects from the Student class. Each object we create from a class is called an instance of that class. If I walk into a classroom to find Mr. Smith and 20 students, Mr. Smish is an instance of the Teacher class, and each of the 20 students is an instance of the Student class. That word "instance" leads to this great verb we use in programming. When we create an object from a class, we say we're "instantiating" the class.

When we instantiate a class, each attribute needs a value. Our teacher instance will need to have a name, a subject, and an office location. Each student instance will need to have a name, a student ID, and a grade. Setting those values is part of the instantiation process.

One of the great advantages of OOP is that once I'd written the code for a class, I can make as many instances as I want. There are going to be a bunch of students in our classroom and each instance has attribute values that are separate from the other instances. Javier has a grade, and if his grade changes, that has nothing to do with Vanessa's grade.

With that understanding of what a class is, and how classes relate to objects, we can talking about implementation--and by implementation I mean taking writing the code to define these classes. When it's time to write code, these attributes are going to become variables. You've been using variables since almost day one of your programming journey, 



''''



. And each object can have different values for its attributes. So I can have a teacher named Mr. Smith, and a teacher named Mrs. Jones. I can have a student named John, and a student named Jane. Each of these objects will have the same attributes and behaviors, but they can have different values for those attributes. 



We call this process instantiation. When we instantiate a class, we're creating an object from that class. So if I instantiate a Teacher object, I'm creating a specific teacher with a name, a subject, and an office number. If I instantiate a Student object, I'm creating a specific student with a name, a student ID, and a grade.
