Once we can work with variables and create methods, we're ready to start learning about object-oriented programming, or OOP--beginning with a general look at what OOP is, and how our programs can be organized into classes and objects.

So, what is Object-Oriented Programming? A technical way to define it is to say that in OOP, we're taking data and the code to manipulate that data, and bundling them together into objects, instead of keeping data separate and passing it into the methods that need it, which is the procedural programming we've been doing. That's an accurate description of OOP, but I'm going to encourage a more intuitive way of thinking about it.

What I like to say is that OOP lets us think about programs the way we think about the world around us. I'm sure there are exceptions, but I think most of us tend to see the world as a bunch of objects interacting with one another. When we walk into a classroom, we see a teacher and some students, and they're talking to each other. We see the teacher writing on a whiteboard and we see students typing on laptops. All of those objects have information that's associated with them. The teacher has a name and a subject they teach; each student has a name and a student ID. The objects also have things they can do, or things other objects can do with them. The teacher can ask the students a question, and a student can answer. The teacher can write on the board, and students can take notes on their laptops.

OOP gives us the ability to see our programs in the same way--a bunch of objects that have information and behaviors, and those objects interact with each other. Game development makes for really straightforward examples of this. In a game like Fortnite, you have a player object, and that player object has a position, a health level, and a score. The player object can move, jump, and shoot. The player object interacts with other objects in the game, like the environment and other players. The player object can collide with the environment, shoot at other players, dance when they win, and so on. 

But as we'll see, OOP isn't just for game development. OOP is popular enough that if you go into software development, you're going to work with it. You might not be doing it 100% of the time, and it might not be the only thing you do, but it's just too pervasive to avoid.

In OOP, everything begins with classes. Until now, our class has been the entire program, starting with a main() method and containing other methods to help us stay organized. But in OOP, the main purpose of a class is to be a blueprint for creating objects. If you picture an old-school set of blueprints, that really has all the information you need to build a house. The blueprint tells you how big the house is, how many rooms it has, where the windows are, and so on. 

Another popular analogy for a class that might work better for you is a recipe. And again we'll go old school and think about a recipe written on an index card, maybe like your grandma has. The recipe tells you what ingredients you need, how much of each ingredient, and what steps you need to follow to make a cake.

A blueprint by itself isn't very useful. It doesn't actually provide any shelter other than maybe holding it up over my head if it starts to rain. And I can't eat a recipe. But I can take that blueprint and make a bunch of houses from it, and I can make a bunch of cakes from that recipe. 

Let's go back to that idea of a classroom and look at it as an OOP example. To help us visualize these classes and objects, we're going to use some simple diagrams. If you're curious, this is called UML--though I'm simplifying it a lot since we're beginners. But it's the standard format every programmer uses to draw class diagrams.

The top of a class diagram has the class name, and we'll start with the Teacher class. You know I'm uptight about identifiers, so I'll point out the capital T at the beginning and the lack of an S at the end. Even though I can have a bunch of teachers, the class or blueprint is singular. Remember, one recipe, a bunch of cakes. If a class name has multiple words, we capitalize the first letter of each word--so it's the same as our variables and methods, but we indicate that it's a class by starting with a capital. If you're nerdy like me, you're dying to know that this is called PascalCase, because it is used in an old programming language called Pascal. [named after Blaise Pascal, show a picture]

Below the class name, I'm going to list the things we need to keep track of related to a teacher. A teacher has a name, a subject, an office number, and you can imagine a bunch of other things. These are the things that make an individual teacher unique, and we call them attributes. Below the attributes will be all of the things a teacher can do, or that we can do with a teacher. Lecture, call on a student, write on the board and so on. We call these behaviors.

If we look around the classroom and see what other objects are there, we'll see students. So we'll have a Student class. The Student class will have attributes like a name, a student ID, and a grade. And behaviors like raise a hand, fall asleep, and ask a question.

Again, these classes are blueprints, so they define what a teacher is and what a student is. In order to use them in a program, we'll need to create objects from them. I'll need to have one object from the Teacher class, and I'll need to make a bunch of objects from the Student class. Each object we create from a class is called an instance of that class. If I walk into a classroom to find Mr. Smith and 20 students, Mr. Smith is an instance of the Teacher class, and each of the 20 students is an instance of the Student class. That word "instance" leads to this great verb we use in programming. When we create an object from a class, we say we're "instantiating" the object.

When we instantiate an object, each attribute needs a value. Our teacher instance will need to have a name, a subject, and an office location. Each student instance will need to have a name, a student ID, and a grade. Setting those values is part of the instantiation process.

One of the great advantages of OOP is that once I'd written the code for a class, I can make as many instances as I want. There are going to be a bunch of students in our classroom and each instance has attribute values that are separate from the other instances. Javier has a grade, and if his grade changes, that has nothing to do with Vanessa's grade.

With that understanding of what a class is, and how classes relate to objects, we can starting thinking about implementation--and by implementation I mean the code to define these classes. When it's time to write code, these attributes are going to become variables. The class's behaviors are going to become methods.

But we're fancy object-oriented programmers now [monocle image?], so we're going to start looking at our variables and methods a little differently, especially when we think about variable scope. In our procedural approach to programming, before we had a glow up and got all fancy [same image], variables were scoped to the method they were declared in. But in OOP, we're going to think about variables as being scoped to an instance of the class--a variable belongs to an object. When I instantiate a Student object, that object has a variable for a grade and it's accessible by any method that is also part of that Student instance. So a fallAsleep() method can access and change the grade variable, probably in a negative way. But the other methods can also access that grade without having to pass it around, so maybe asking a good question can change the grade to make up for falling asleep.

With our fancy new approach we'll have fancy names, too. So now these variables are called "instance variables" or "fields," and the methods that work with them are called "instance methods." 

Once you've made the shift to thinking about objects with fields and instance methods, you've got a good foundation for learning object-oriented programming. From here, we'll learn some important design considerations and start building our programs from an OOP perspective.