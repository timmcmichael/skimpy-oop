:imagesdir: images
:sourcedir: source
// The following corrects the directories if this is included in the index file.
ifeval::["{docname}" == "index"]
:imagesdir: chapter-4-classes/images
:sourcedir: chapter-4-classes/source
endif::[]

== 0100 - Classes and Objects (Chapter 4)

=== #Content for this module is under construction. For now, the section headers below direct you to the corresponding chapter in our required textbook so that you don't have to wait for me to finish.#
// TODO: Upload source files to GitHub archive
// TODO: Canvas - update/remove embedded video to new version.


// === What's the Point?
// * 

_Source code examples from this chapter and associated videos are available on https://github.com/timmcmichael/EMCCTimFiles/tree/4bf0da6df6f4fe3e3a0ccd477b4455df400cffb6/OOP%20with%20Java%20(CIS150AB)/04%20Classes%20and%20Objects[GitHub^]._

''''

=== OOP Basics

#This section is almost finished, but in the meantime you can instead read section 4.1 (page 115) in the textbook.#

Until now, we have been organizing our programs into methods, which is a procedural programming approach.
We've been thinking of a program as a collection of tasks that need to be performed in a specific order.
There's nothing wrong with this approach, but it can get cumbersome as a program grows in size and complexity--and it isn't always an intuitive way to plan our programs.

Now we're ready to start our transition to object-oriented programming (OOP), which lets us think about programs the way we think about the world around us.
Instead of thinking about a program as a bunch of tasks, we can think of it as a bunch of objects that interact with each other.
As an example, the old-school video game https://en.wikipedia.org/wiki/Pac-Man[*Pac-Man*] has the main character (an object) moving around a maze (another object), and avoiding four ghosts (yep, four more objects).

.Pac-Man arcade game, released in 1980 by Namco
image::pac-man.png["Screen shot of Pac-Man gameplay", width=500]

If we decide to create Pac-Man, we'll still be using methods, but they won't be the basic building blocks of our programs.
Instead, we'll be organizing our programs into *classes*, which are blueprints--or recipes--for creating *objects*.
A class defines the *attributes* and *behaviors* of the objects--and those are the variables and methods we'll write to create our programs.

.Time To Watch!
****
Intro to OOP: Classes and Objects 

#A new versions of this video is on the way. For now, you can use the older version.#

video::wMaFcokumBs[youtube]

// video::xxxxx[youtube, list=PL_Lc2HVYD16Y-vLXkIgggjYrSdF5DEFnU]
****

In OOP, our planning for a program starts by deciding what objects--and therefore, what classes--we'll need in order to implement the functionality we want.
To help organize our thinking, we'll use a tool called a *class diagram*, which gives a visual representation of the classes and their relationships in our program.
The format programmers use for class diagrams is called UML (Unified Modeling Language). 
The UML standards are extensive, but we'll be using a simplified version in this course. 

Consider a program that a restaurant might use to handle orders. A simple class to represent an order might look like this:

.Example of a class diagram for a restaurant order
[plantuml, target="OrderDiagram", format=png]
----
@startuml
skinparam classAttributeIconSize 0
class Order {
   -serverName:String
   -tableNumber:int
   -appetizer:String
   -entree:String
   -dessert:String
   -totalPrice:double
   +void sendToKitchen()
   +void printBill()
   +double closeBill()
}
@enduml
----

The top section of the digram has the name of the class, which is `Order`.
The next section is for the attributes of the class--the information the class will store. This example has attributes for the server's name, the table number, the items ordered, and the total price.
The bottom section is for the beahviors of the class, which are the actions the class can perform (or that we can do with the class).
With an order, we might send it to the kitchen, print the bill, or close the bill.

We'll learn more about the symbols and conventions of UML as we go along, but for now the important part is that we can use class diagrams to help us plan our programs--and to talk about OOP concepts without bogging down on code details.

.Interesting
****
Your Canvas course includes access to *Lucid (Whiteboard)*, which is a free online tool you can use to create UML diagrams. If you create your account through the link in the left-hand navbar in Canvas, you'll have access to the premium features for free.
****

Many programs will have multiple classes, and diagramming those before we start coding helps us work out details and find potential problems.
Diagrams are also useful for sharing information about a class for other programmers who might need to use it.

=== Encapsulation

Object-oriented programming is all about creating objects that can interact with each other.
Since the objects will be interacting, we need to think about how to keep them from interfering with each other in ways we don't want.
If we have an `Order` class in a program used by a restaurant, we don't want some other class to change attributes in a way that disrupts the program--like changing the entree selection to something that's not on the menu, or setting the price to a negative number, for example.

To prevent this kind of tampering, whether it's intention or accidental, OOP relies on a concept called *encapsulation*.
Encapsulation of a class means that attributes are hidden from the outside world, and only the behaviors of the class can access and change them.
As an analogy, consider the counter at a fast food restaurant. You can't just reach over and grab a handful of fries; you have to ask the employee behind the counter to get them for you.
In this analogy, the food is encapsulated and you can only access it by using a behavior, like "order food".

Another way to think of encapsulation is the way we interacte with other people in social situations.
When we encounter a stranger, they don't automatically know our name and phone number; they have to ask us for that information.
We've encapsulated our personal information, and we only share it when and how we choose to.

In Java, encapsulation is not a strict requirement, and our code will still work if we don't use it.
But it's a best practice--and an important one--so we will encapsulate all of our classes in this course.
In fact, I would argue that if you don't encapsulate your classes, you're not really doing object-oriented programming. 
And that's what we're here to learn.

=== Defining a Class

#This section is not finished, but in the meantime this content is covered in section 4.2 (page 117) and 4.3 (page 119) in the textbook.#

// Mention that fields look like global variables, which we know are evil. These are instance variables


=== Instantiating and Using Objects
#This section is not finished, but in the meantime this content is covered in section 4.4 (page 124) and 4.5 (page 127) in the textbook.#


// At this point, students can complete lab assignments in Canvas. The rest of this content is needed for the programming project.

=== Constructors
#This section is not finished, but in the meantime this content is covered in section 4.6 (page 130) in the textbook.#

=== `static` Constants and Methods
#This section is not finished, but in the meantime this content is covered in section 4.8 (page 139) in the textbook.#

''''

//// 
Object-oriented programming (OOP) is a programming paradigm that uses "objects" to design applications and computer programs.  
Objects are instances of classes, which can be thought of as blueprints for creating objects.  
A class defines a set of properties and methods that are common to all objects of that type.  
By using classes and objects, developers can create modular, reusable, and maintainable code.  

Classes serve as templates for objects, encapsulating data for the object and methods to manipulate that data.  
This encapsulation helps in bundling the data with the code that operates on it, thus promoting data hiding and abstraction.  
For example, a class `Car` might have properties like `color`, `model`, and `year`, and methods like `startEngine()` and `stopEngine()`.  
Each `Car` object created from this class will have its own set of these properties and methods.  

Objects are the concrete instances of classes.  
When a class is defined, no memory is allocated until an object of that class is created.  
Each object can have different values for its properties, even though they share the same structure and behavior defined by their class.  
This allows for the creation of multiple objects with similar characteristics but different states.  

The use of classes and objects in OOP promotes code reusability.  
Once a class is defined, it can be used to create multiple objects without rewriting the same code.  
This makes it easier to manage and update code, as changes to the class definition automatically propagate to all objects instantiated from that class.  
Additionally, OOP supports inheritance, where a new class can inherit properties and methods from an existing class, further enhancing code reuse and organization.  

Overall, classes and objects are fundamental concepts in OOP that help in organizing complex software systems into manageable, modular components.  
They provide a clear structure for modeling real-world entities and their interactions, making it easier to design, develop, and maintain software applications.  

''''

=== Examples of Classes for Beginners

When you're starting out with object-oriented programming, it's helpful to work with classes that are easy to understand and relate to real-world objects. Here are some good examples:

1. **Car Class**
   - Attributes: color, model, year, speed
   - Methods: startEngine(), stopEngine(), accelerate(), brake()

2. **Person Class**
   - Attributes: name, age, gender, height
   - Methods: walk(), talk(), eat(), sleep()

3. **Book Class**
   - Attributes: title, author, ISBN, numberOfPages
   - Methods: open(), close(), readPage(), bookmarkPage()

4. **Dog Class**
   - Attributes: breed, age, weight, name
   - Methods: bark(), eat(), sleep(), fetch()

5. **BankAccount Class**
   - Attributes: accountNumber, accountHolder, balance
   - Methods: deposit(), withdraw(), checkBalance()

These examples help students understand how to define attributes and methods, and how to instantiate objects from classes. They also provide a foundation for more complex programming concepts as students progress.

=== Defining a Class


////


// === Check Your Learning

// ==== Can you answer these questions?

// ****

// 1. 

// 2. 

// ****