okay so we understand how inheritance  works on a basic level we've gone into  Java and we've extended a class we've  tested that to make sure it's working on  a very basic level for the next part we  need to understand how method calls work  in an object-oriented programming  environment we're going to consider a  situation in which we have two classes  that we're going to start with we're  going to have a friend class and a  family member class and these classes  will encapsulate all the things that we  keep track of about these two different  uh sets of people and all the behaviors  that they  have we then are going to add a close  friend class now a close friend is  probably a lot like any other friend but  maybe has some special behaviors um that  a regular friend doesn't have and so we  can consider a an inheritance  arrangement here we would say a close  friend extends friend and this setup  does pass our is a test right this is  where we say well a close friend is a  friend that works and so that suggests  that this is probably a good arrangement  for our  inheritance if we add another class to  the mix that is um best friends and  turns out that our best friends are our  cousins  so now we have this class that causes a  little bit of a problem is a best friend  cousin a friend or is a best friend  cousin a family member The Logical  solution here would be that it can  extend both right because a a best  friend cousin is a friend and a best  friend cousin is a family member but as  the Beatles might say you can't do that  at least you can't do that in Java this  would be called multiple inheritance and  it's where a subass has more than one  super class that it extends some  programming languages do allow this and  the problem with it is that you can run  into situations where there's a an AM  ambiguity concern right we want to run a  method in one of the super classes and  we don't have any way to be sure which  one gets priority here so the developers  of java just avoided it and said well  we're just not going to support that  we're not going to let you do  it Java does have something called  interfaces and interfaces give us kind  of a workaround they give us a way that  we can have something like multiple  inheritance but that avoids that  ambiguity problem that's beyond the  scope of what we're talking about here  but it is an option so in Java we can't  do multiple inheritance in that sense  but what we can do is what we might call  multi level inheritance and that is to  say that um one class can have a super  class and can have only one super class  but that super class can also have a  super class and that super class can  have a super class and we can go as far  up there as we need to  go this idea ends up resulting in what  we can call an inheritance hierarchy  which is the kind of a visualization of  how all of these inheritance  relationships fit and there probably  would be other branches to this like for  example we might have a work friend for  someone who you don't really like but  there's nobody else at work so you have  to hang out with them there or like a  friend of me that you are nice to each  other's faces but then talk bad behind  each other's backs those would be whole  other sections of this hierarchy we're  just going to figure um on talking about  this one kind of branch that happens to  fit nicely on my screen right now  now these three  classes all  have methods they all have behaviors  that they offer right so a friend can  give us a hug a close friend can be  honest with us if we ask them do these  shoes make my feet look big they'll give  us a true answer but since a close  friend is also a friend they inherit the  ability to give us a hug that means of  course that a best friend inherits the  ability ility to be honest about our  shoes and to give us a hug all the way  up the inheritance tree we get to  inherit all that stuff and then a best  friend adds on the ability to lend  money now because these inheritance  hierarchies can get complicated and big  it's important for us to understand how  method calls work so let's imagine that  we have an instance of the best friend  class and we're going to call it  BFF and we want to call the honest  opinion method for that BFF we need to  ask them about a pair of shoes we're  thinking about buying so here's what the  compiler does it's going to look and see  that okay BFF is an instance of best  friend so it goes to the best friend  class and it looks for this honest  opinion method of course it's going to  look around here and not see that but  what it is going to see is that oh best  friend doesn't have an honest opinion  method but it does extend close friend  so I better go look there and so it's  going to go up the inheritance hierarchy  one level and it's going to look in the  close close friend class and it's going  to look and see oh here's an honest  opinion method so I'm going to use  that if we try and call a method that  doesn't exist like we try and ask our we  want to ask our BFF to go on a date  which is not a behavior that a best  friend has we probably shouldn't be  doing that that but it's going to come  to the best friend class it's going to  look around say hey I'm looking for a  method to to go on a date nope but this  extends close friends so let's go look  there looks around no go on a date  method there but that extends friend so  we better go to friend and look  no go on a date method here either and  so now we have a crash right once it  gets to the top of the inheritance  hierarchy if there's no method there  where our code is not going to compile  now we're going to see in a little bit  that there's a little bit more to this  there's kind of one more step in the  process but for now that's our  understanding of how this works a method  call is going to start out in the subass  and it's going to work its way up  through super classes until it finds an  implementation it's looking for now what  happens if we have a situation where a  subclass inherits a behavior but it does  that behavior in a little bit of a  different way so for example a close  friend inherits the ability to give a  hug but a close friend hugs in a  different way than a friend does right  this type of situation is called  overriding right not to be confused with  overloading which is a a topic that you  probably learned about previously in  method overriding it means that a subass  is going to uh customize an  implementation for a method and because  we understand the way that a method call  works up the inheritance hierarchy we  know that a best friend if we call the  the give hug method it's going to move  up until it sees an implementation for  that essentially it means that a best  friend hugs the way that a close friend  does which is maybe a little different  than the way a friend hugs all right so  this is all great with these examples of  friends and best friends and things like  that but let's go ahead and connect this  a little more to some code that we're  going to write so um here's an example  uh that we have used in previous videos  it's a bank account super class and then  we have implemented a checking account  we also implemented a savings account  that's not shown here uh and what we  want to add right now is a VIP checking  account so that we have that idea of  multi-level uh inheritance right a VIP  checking account is a certain type of  checking account and I I don't know it's  going to you get a little bonus when you  make a deposit if you're a  VIP what I want to point out  here is that the VIP checking account  has a deposit method just like a bank  account does so this is an example of  overwriting it's a little different than  our previous example because we're  skipping one class in the middle it  doesn't matter the idea of an override  is that we're going to implement a  method to replace something somewhere up  the inheritance hierarchy right so um a  a deposit for a VIP checking account  Works a little bit differently than a  deposit for a bank account which is  inherited by a checking  account if we look at that checking  account I do want to point out we have a  right check method that really is almost  the same as a withdraw method right they  both withdraw money from the account uh  writing a check involves a little bit of  other  information this is not actually an  example of overwriting for it to be  overwriting you have to use the exact  same method name all right so the  deposit  methods this uh VIP checking account  deposit overrides the bank account  deposit the right check method happens  to do something very similar to the bank  account withdraw but it's not really  overriding let's go ahead and jump into  Visual Studio code and see some examples  of this and you can get the the files  that I'm using from  canvas I've spent all this time talking  about friends and close friends and best  friends we should at least see a little  example of this in code I I don't even  know if I'll post these files because  they're just really simple classes the  first one is a friend class and it has a  give hug method so if I come over here  to my test  program which just makes um one instance  of each so I can say  friend. give  hug and if I run that it says this is a  friendly hug now if I have a close  friend so I'm going to delete  that and I have my close friend dot um  what can a close friend do oh the close  friend can give an honest opinion so  I'll run  that so our inheritance seems to be  working let's take a little bit of a  look at the overriding so my close  friend  class extends  friend it has an honest opinion method  and then it has a give hug method so  this is the over ride when I have my  best F my close friend or best friend  because it inherits from that um give a  hug it shouldn't say this is a friendly  hug this  time it says this is a close friends hug  and if I change that to BFF BFF inherits  give hug from best uh from close friend  so we should get that same  output so far so good U there's not much  to this syntax here but you got to be  careful that you are naming and  including case sensitivity uh your  method the same as the super class  method you overwriting and to help you  with that um there's something we call a  compiler directive and so this is the um  at sign and I'm going to say at  override and this has no impact on the  execution of the program this is just a  message to the compiler that says hey  this next method is supposed to be  overriding something in a super class  again it doesn't change oops that one's  not going to run let me switch over to  my test uh it doesn't change the way  anything  runs still says this is a close friend's  hug what it does is it helps catch any  mistake you might make when you're  overriding because it's really easy for  example to have a  typo without that  override directive there that doesn't  give an error because this is not bad  syntax it's called give hug without the  e in there well Java does doesn't know  that's a misspelling it's just another  method but when I run my code now save  that come over here and run  it I should be getting a close friends  hug but instead I'm getting giving a  friendly hug I called give  hug it came I came to best friend didn't  find any of those it came to close  friend it didn't find the correct give  hug it found this other one but it  didn't use it and it went up to friend  and it ran that one so the override  directive is just just a way to um help  catch the errors that you might make um  I often forget to use it but I I  encourage young programmers beginning  programmers to use that because it's it  is easy to to mess those kinds of things  up so that's just a really basic example  of multi-level inheritance and Method  overriding let's switch gears and look  at that bank account example okay so  this is my bank account class I think  it's pretty much where I left it off  after that last video um nothing  particularly interesting to us here at  the moment um then I've got my checking  account which extends a bank account and  it adds the ability to write a check and  the one I'm creating is going to be  called a VIP checking account and so now  when I go to extend this I'm going to  say extends checking account because  this VIP account is a form of a checking  account and I misspelled extends there  we go and the idea here is I want to  override the deposit method and we're  going to make it so that if you have a  VIP checking account because you're rich  and fancy and have one of those little  monal things in your eye um whenever you  make a deposit you're going to get like  a  05% um bonus or something like that so I  have that override compiler directive  and now I'm going to say  public and I've forgotten I don't  remember what my deposit method looks  like so I'm going to go check um a  deposit  method um it's a void method it takes an  amount and by the way it wouldn't have  to be exactly uh this I'm just I can't  remember what it was and so I want to  get it right the first time U but okay  so it's G to be public void deposit and  if I was messing it up the compiler  override would help me anyway double  amount  all right so first thing I'm going to do  is I'm going to calculate a um a bonus  here double bonus  equals amount times I'm never good at  math but if I want  0.5% half a percent I believe that's  0.05 am I doing that right  0.5 point I think I went one Z too far  we'll find out um and then we're going  to say that this dot  balance equals or we'll just say plus  [Music]  equals  bonus now we've run into this error that  we have seen previously balance is a  private variable in bank account so I  don't have access to it remember that we  had two solutions I could uh I could  change that private keyword to protected  and that would give me access to it and  that's not a bad solution I I certainly  don't want to change it to public I  think I made that clear in the other  video but I can change it to um I can  change it to protected and that would  give me access and I said I also could  just call a method uh in the previous in  the super class excuse me so if I say  deposit and I'm going to deposit the  bonus plus the amount  let's see what happens if we run this so  I'm going to come to my test account I'm  going to um not going to write the check  I'm going to try and make this as simple  as possible so I'm going to put in  $100 right because a nice even number  and then we're going to print out that  balance oh and I I almost made a mistake  here I need to change my checking  account to a  VIP checking  account and I probably should rename  that so I don't confuse myself again um  I like to use a little rename um  function in vs code because then it's  sort of like a global find and replace  there let's go and run this and see what  happens I've got this odd  error okay I've got this message that  has printed out a whole bunch of times  and I'm not sure what's going on here  well I am but but you're not sure so  let's take a look we're going to use the  um the debugging feature in uh in VSS  code for this I'm going to set a break  point and let's run this again and see  what  happens oh and I've made a mistake I I  ran it instead of saying debug it so I  got to change that to say debug Java  there we go now we've stopped and here I  am at the um VIP checking account equals  new VIP checking I can step over that I  can step over that but this is the one  I'm interested in I want something's  going wrong when I'm doing my deposit so  I'm going to step into that  method and I've got some variables over  here amount is equal to 100 that's  good I'm going to step over that and my  bonus is now  0.5 okay so um 50 cents I think that's  right again if my math um is is uh  serving me correctly and now I've got  this call to deposit remember I want to  call the deposit method in my super  class so that it just does that deposit  for me so I'm going to step in here oh  and it didn't go to my super class it  stayed right here in VIP  checking and it's just going to keep  staying here it's calling itself so we  call this recursion and there are there  is a way to use recursion uh  intentionally where it essentially is a  loop but I haven't done that here this  is just an error and what happens is  every time you call a method the Java  runtime copies a bunch of stuff related  to that method and puts it in a place on  the memory called the stack and  eventually that stack runs out of uh  runs out of room and we say that the  stack overflows right so I'm getting a  stack Overflow error you probably know  that phrase stack Overflow as the site  where you go to cheat when you're stuck  on one of your homework problems but  that's where it gets its name it's from  this idea of a stack Overflow error when  the U when that area of memory runs out  so we've got to solve this  problem I again I could just change it  to protected but this is a good chance  to teach a little concept here I don't  want to call this deposit method I want  to call the deposit method for my super  class so what I can do in Java is say  super. deposit and the super keyword um  this is essentially like you know I've  always do things with like this okay  this do deposit would refer to this  object super refers to the super class  so now let's try let's save that and try  running it see if that solves our  problem turn off my breakpoint and be  optimistic that this is going to  work okay $100 50 so it did  work the concept here is that when we  have a need to call the super class  version of a method specifically we can  sort of prefix that with super Dot and  it will jump to that super it and what  it actually does is it just starts  moving up the inheritance tree from here  until it gets to another uh  implementation of deposit because  remember the super class here is  checking account checking account  doesn't have a deposit method so then  that extends bank account it comes to  bank account and it finds it there um  this is a concept that we're going to  come back to in an upcoming video  because it has a really important role  this uh this idea of calling a super  class uh when we get to  it but for now this is just a nice  little example of how we can have  multi-level inheritance and how method  calls are going to move up that  inheritance hierarchy uh and allow us to  do things like method over overwriting  which is giving a custom implementation  of a method within a super class now a  few minutes ago I talked about how a  method call moves up the inheritance  hierarchy in this case BFF go on date  which doesn't exist and when it gets to  the highest level super class it then  essentially won't compile from there but  I had that little comment that that's  actually not quite it there is another  step to the process so there is one more  thing that plays into this um idea of  method calls and this hierarchy and it's  probably easiest to just go into Visual  Studio code and show you all right  there's a method that has kind of a  special behavior in uh Java it gets  treated a little bit differently than  most other methods and so I'm going to  demonstrate this by using a print line  statement and what I'm going to print  out is just my instance of the VIP  checking account object so that's VIP  one now VIP P1 is not a string it's an  object if I run this I'm going to turn  off debugging here and just run it  regular what I get when I print out an  object it looks sort of nonsensical it  actually is it does mean something so  you can read some of it it's the name of  the class that this object is an  instance of and then it's got this thing  that we call a hash code it's you can  think of it as kind of an address uh in  memory where this  where this object is can be found so  it's it helps um helps the runtime find  this object when it needs to use it  well what happened here is that the  print line method really just takes a  string and a vip1 is not a string it's a  VIP checking  account so what the compiler has done  essentially is it it's added on to that  a little method called called two string  as in we're going to convert that object  to a string and if I run this it should  work exactly the same way because  essentially I believe the compiler  actually is just adding that call on  when it when it compiles I think I'm  accurate when I say that uh but  certainly conceptually that's what's  happening so um where does that come  from it turns out that there is one  class to rule them all in Java and that  is a class that is called object and  since I don't have a fancy PowerPoint up  there for this uh object a class called  object and every class in Java extends  object if it doesn't extend something  else so in other words VIP checking  extends checking account and it can't  extend anything else because there's no  such is multiple uh inheritance in Java  but checking account then extends bank  account bank account finally we get to  one that doesn't extend anything so  again I'm not sure if I'm 100% accurate  but I think we can think of it as the  compiler is inserting a line here that  says extends  object all right and the object class  provides a handful of functionality that  every object in Java needs to have there  aren't a lot there's not a lot to it you  can look it up online if you're curious  but the main one that we interact with  is this two-ring method right because  often we want to print out an  object it is a method just like any  other method so I can overwrite it just  like any other method so I'm going to  come to my VIP checking account and I'm  going to use the  override co uh compiler directive again  so the two string I happen to know this  you would have to look it up if you  didn't but public string two  string and I um I've misspelled it that  was not intentional but it does  reinforce the idea of this compiler  directive because if I didn't have it um  it would think that oh well I'm getting  a different error now sorry that because  I'm not returning anything yet so let's  just uh return VIP for now but now I'm  getting an error because uh because I  misspelled that and if I have that  override directive turned off it thinks  that's just fine again it doesn't  understand that it's a that it's a  misspelling so I'm overwriting two  string and if I come and run my code  again now instead of printing that uh  class name and the hash code it prints  out whatever the two string method  provides  in general what we use this for is I  mean the way I explained it is we want a  text representation of the object and so  um I might say  VIP checking  account and then a new line and I'm  going to say balance  equals and remember this. balance is  private so I can't use that but I can  use the getter  and I'm going to return that once I fix  my  typo and this is typically the kind of  thing you use a two string method for um  I often uh will just have it sort of  dump out all of the all of the fields in  my class just so that I can run my code  I can print it out I can print out an  object and I can just see what all the  instance very variables are so this is  another example of overwriting right in  this case we're overwriting the two-  string method even though we didn't  write it and up until a few minutes ago  we maybe didn't even know that it  existed I think this is a good place to  stop as is always the case just reach  out if you have any questions  