when I talk about object-oriented  programming I often talk about these  four pillars of object-oriented  programming and it's not that I think  it's important that you know what these  four pillars are I just think they are  uh instructive about what we consider to  be important in object-oriented  programming one that I haven't talked  about yet is  polymorphism and in this video we're  going to talk about polymorphism um in  the context of arrays and we're not  really going to go any deeper than that  we're not going to go into any other  uses of  polymorphism uh but in order to  understand what we're doing you are  going to need to know how to use arrays  and you are going to need to be um  fairly familiar with inheritance at this  point you need to know how to extend  classes and need to understand how uh  method overwriting  works so polymorphism gives us the  ability to treat instances of different  classes as if they were objects of a  shared super class what the heck does  that mean what it means is that if we  have a checking account and a savings  account object we can treat both of  those the same as long as we're treating  them as bank accounts because they both  uh inherit or they both extend bank  accounts so that means that um  regardless of whether it is specifically  a checking account or specifically a  savings account we can make withdrawals  deposits we can get the balance all  those shared um elements of those two uh  subclasses now the advantages of being  able to do that may not be obvious right  away so let's take a look at how this  applies to something like an array if we  consider that we have made an array of  checking account objects that hold six  uh  instances I can put obviously checking  account objects in that but if I try and  put a savings account object into that  array it doesn't work right and this  goes back to our basic understanding of  arrays which is they can hold um a  collection of things as long as those  things are all of the same data  type what polymorphism says is that if  we change this array and instead of  making it an array of checking accounts  we make it an array of bank accounts now  that savings account can go in that same  array and we can have an array that  holds a mix  of any subass of the bank account class  and we can interact with those in an  array and we've already seen that when  you have an array first of all you can  hold big amounts of data but just as  importantly we can run Loops through  that data and we can process it really  efficiently so this gives us a way to  handle all of our accounts in one  array let's take a look at how this  would work in code here I've got this  array of checking account objects and  I've attempted to put six instances into  that array and the ones that are using  the checking account Constructor are  working just fine but anytime I try and  use that savings account Constructor I'm  getting a compiler error as we discussed  just a moment ago we can change this  from a check-in account to a bank  account and I'll have to change it in  both places here for the moment um now  those will at least compile I'm then  going to  deposit money into them I'm going to run  it right uh real quick just to make sure  it really is working and it is there's  no output because this program doesn't  produce any output yet and let's just  start by doing a traversal Loop to go  through and get the balances of these uh  these objects so for in I equals zero  this is just our good old fashion uh  traversal array  and so now I'm going to print out the  balance for each of these in order  balance  equals and we'll just say accounts I do  get  balance let's go ahead and run that see  if that  works so we are off and running the idea  here is that I we've already seen it  working because in the uh in the lines  of code here where I'm making deposits I  am successfully count uh calling um  super class methods for instances of  each of these subclasses so it is  working but the the more important thing  is that in my array I can have this  array of as many accounts as I want and  each element in that array can be from  either subass and it will still work  there are some implications here to be  aware of um one of them for example is  that I can't call any methods that are  specific to one of the sub classes so if  I say accounts and let's pick one of my  savings account account  five well I'll just put I we're in the  loop so I'll put I um and I'll say add  interest which is one of my subass  methods that's a savings account method  that won't compile right because it's  looking at this as a bank account  remember in polymorphism we're treating  the subass as the super class the  subclass instance I should say and so um  it's looking at it as a bank account  it's essentially starting that um that  method call up the inheritance tree it's  starting at bank account because I've  said that that's what the class is um  and that's not um that's not specific to  the loop so if I take this up here  because that maybe the that I makes it  confusing right because it could we  never know what it's going to be but  even if I pick something that is  explicitly a savings account that still  doesn't work now we have some tricks  that that we're not going to get into  here because it's kind of beyond the  scope of this short little video um  where we can maybe make that work um but  instead of going into depth I just want  to show you a little um example of that  or or a hint of that I should say and  that is that we do have a way we have a  couple ways we can test uh an object  from this array and see which class it  is and so if I say accounts  i. get  class so there is a method called get  class and uh you can see in the output  here it's saying checking account or  sa's account um well where did that get  Class come from we recently have learned  where that probably comes from from when  we call get class it's going to look at  bank account first and doesn't see a get  class method there so every class in  Java inherits from a class called object  remember it's one class to rule them all  well get class is a method in that  object class so any object in Java we  can call get class and find out what it  is an instance of speaking of instance  of we can also make that uh an if  statement by we can there's a Boolean um  it's not really a method it's an  operator but I can say um  if um  accounts  I instance  of savings account  and I misspelled savings account there I  put an S on the end um so this instance  of is a um Boolean operation that  compares whatever's on the left to  whatever's on the right uh or well sorry  it looks at what's on the left and says  is this an instance of the class that I  refer to on the right and it's going to  return a true or false um now it's not  quite as simp Le is then um saying well  okay we know it's a we know it's a  savings account now so let me just add  the interest it's not quite that simple  um that we have to do some downcasting  and some things that again are beyond  the scope of what we're doing here but I  just wanted to point out that we're not  stuck we do have some options there the  other thing that's a little more  relevant to us now with what we know so  far is that um regardless of of  what the instance uh instance of  returns without us having to worry about  it our method calls will move up the  inheritance tree um in terms of  overriding so if I go to my savings  account I have an overridden deposit  here but if I do that if I say public  void deposit and we'll say double  amount and I'm just going to say system  out print line this is a worthless  override but it shows the  point this is a savings  deposit and so uh now I can just do my  super class deposit with the amount and  I don't have to add any other code um so  now if I come back to my uh my test  method here my test program and run this  again  and we're really looking at these lines  of code up  here so uh anytime that we call a  deposit method it is moving up that  inheritance tree I think I kind of  misspoke a few minutes ago we are still  going to move up that inheritance Tree  in terms of overriding right and um it's  not clear what's happening because  they're only they were sort of mixed in  here but every time we deposited to a  savings account it ran ran this  overridden uh this override version of  that deposit method and so it spits out  that little line of text the point here  uh overall is that we are still able to  create an array of bank accounts put the  subclasses in it we can't call the  methods that are specific just to that  subass but if we call a method that's  overridden it will respect that and it  will call the correct version  of our overridden method so this really  has been just the very briefest look at  what polymorphism is it has a lot of  implications Beyond just  arrays but arrays of subclasses is  something that we can put to use right  away and in fact I'm going to ask you to  put it to use right away and it builds  very logically on what we just learned  about in  arrays as is always the case if there's  been anything in this video that you're  not sure about please reach out  